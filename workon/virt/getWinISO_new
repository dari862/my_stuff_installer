#!/usr/bin/env bash
set -e

ROOT_VM_PATH_Builder="/mySSD/test"

disk_size="64G"
ram_size="4G"
cpu_core="2"

OS="windows"
RELEASE="11"
I18N="English International"

username="Docker"
passwd="admin123"
VM_NAME="win${RELEASE}rdpVM"

SHARE_PATH="/usr/share"
OVMF_PATH="${SHARE_PATH}/OVMF"

ARCH=$(uname -m)

echo "Detected architecture: $ARCH"

VM_IP=""
VIRTIO_FILE="virtio-win.iso"

os_name="${OS}-${RELEASE}"
VM_PATH="${ROOT_VM_PATH_Builder}/${os_name}"
FILE_NAME="${os_name}.iso"

unattended_iso_path="${VM_PATH}/unattended.iso"
virt_storage="${VM_PATH}/disk.qcow2"

case "$ARCH" in
    x86_64)
        picked_ARCH="amd64"
        if [ -d "$OVMF_PATH"/x64 ];then
            OVMF_PATH="${SHARE_PATH}/OVMF/x64"
        else
            OVMF_PATH="${SHARE_PATH}/OVMF"
        fi
        ;;
    arm*)
        if [ -d "$OVMF_PATH"/arm ];then
            OVMF_PATH="${SHARE_PATH}/OVMF/arm"
        else
            OVMF_PATH="${SHARE_PATH}/OVMF"
        fi
        ;;
    aarch64)
        if [ -d "$OVMF_PATH"/aarch64 ];then
            OVMF_PATH="${SHARE_PATH}/OVMF/aarch64"
        else
            OVMF_PATH="${SHARE_PATH}/OVMF"
        fi
        ;;
    *)
        if [ -d "$OVMF_PATH"/ia32 ];then
            OVMF_PATH="${SHARE_PATH}/OVMF/ia32"
        else
            OVMF_PATH="${SHARE_PATH}/OVMF"
        fi
        ;;
esac

function web_get() {
    local HEADERS=()
    local URL="${1}"
    local DIR="${2}"
    local FILE=""
    local USER_AGENT="Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.0.0 Safari/537.36"

    if [ -n "${3}" ]; then
        FILE="${3}"
    else
        FILE="${URL##*/}"
    fi

    # Process any URL redirections after the file name has been extracted
    URL=$(web_redirect "${URL}")

    # Process any headers
    while (( "$#" )); do
        if [ "${1}" == "--header" ]; then
            HEADERS+=("${1}" "${2}")
            shift 2
        else
            shift
        fi
    done

    if ! curl --disable --progress-bar --location --output "${DIR}/${FILE}" --continue-at - --user-agent "${USER_AGENT}" "${HEADERS[@]}" -- "${URL}"; then
        echo "ERROR! Failed to download ${URL} with curl."
        rm -f "${DIR}/${FILE}"
    fi
}

# checks if a URL needs to be redirected and returns the final URL
function web_redirect() {
    local REDIRECT_URL=""
    local URL="${1}"
    # Check for URL redirections
    # Output to nonexistent directory so the download fails fast
    REDIRECT_URL=$(curl --disable --silent --location --fail --write-out '%{url_effective}' --output /var/cache/${RANDOM}/${RANDOM} "${URL}" )
    if [ "${REDIRECT_URL}" != "${URL}" ]; then
        echo "${REDIRECT_URL}"
    else
        echo "${URL}"
    fi
}

function create_autounattend_xml() {
    if [ -f "${VM_PATH}/unattended/autounattend.xml" ];then
        return
    fi

    Drivers_path_="w${RELEASE}\\${picked_ARCH}"

    cat << EOF > "${VM_PATH}/unattended/autounattend.xml"
<?xml version="1.0" encoding="utf-8"?>
<unattend xmlns="urn:schemas-microsoft-com:unattend">

  <settings pass="windowsPE">

    <component name="Microsoft-Windows-International-Core-WinPE" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS" xmlns:wcm="http://schemas.microsoft.com/WMIConfig/2002/State" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
      <SetupUILanguage>
        <UILanguage>en-US</UILanguage>
      </SetupUILanguage>
      <SystemLocale>en-US</SystemLocale>
      <UILanguage>en-US</UILanguage>
      <UserLocale>en-US</UserLocale>
    </component>

    <component name="Microsoft-Windows-Setup" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS" xmlns:wcm="http://schemas.microsoft.com/WMIConfig/2002/State" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
        <RunSynchronous>
                <RunSynchronousCommand wcm:action="add">
                    <Order>1</Order>
                    <Description>BypassTPMCheck</Description>
                    <Path>cmd /c reg add "HKLM\SYSTEM\Setup\LabConfig" /v "BypassTPMCheck" /t REG_DWORD /d 1</Path>
                </RunSynchronousCommand>
                <RunSynchronousCommand wcm:action="add">
                    <Order>2</Order>
                    <Description>BypassSecureBootCheck</Description>
                    <Path>cmd /c reg add "HKLM\SYSTEM\Setup\LabConfig" /v "BypassSecureBootCheck" /t REG_DWORD /d 1</Path>
                </RunSynchronousCommand>
                <RunSynchronousCommand wcm:action="add">
                    <Order>3</Order>
                    <Description>BypassRAMCheck</Description>
                    <Path>cmd /c reg add "HKLM\SYSTEM\Setup\LabConfig" /v "BypassRAMCheck" /t REG_DWORD /d 1</Path>
                </RunSynchronousCommand>
            </RunSynchronous>
      <DiskConfiguration>
        <Disk wcm:action="add">
          <CreatePartitions>
            <CreatePartition wcm:action="add">
              <Order>1</Order>
              <Type>Primary</Type>
              <Extend>true</Extend>
            </CreatePartition>
          </CreatePartitions>
          <ModifyPartitions>
            <ModifyPartition wcm:action="add">
              <Active>true</Active>
              <Extend>false</Extend>
              <Format>NTFS</Format>
              <Letter>C</Letter>
              <Order>1</Order>
              <PartitionID>1</PartitionID>
              <Label>Windows ${RELEASE}</Label>
            </ModifyPartition>
          </ModifyPartitions>
          <DiskID>0</DiskID>
          <WillWipeDisk>true</WillWipeDisk>
        </Disk>
      </DiskConfiguration>

      <ImageInstall>
        <OSImage>
          <InstallTo>
            <DiskID>0</DiskID>
            <PartitionID>1</PartitionID>
          </InstallTo>
          <WillShowUI>OnError</WillShowUI>
          <InstallToAvailablePartition>false</InstallToAvailablePartition>
          <InstallFrom>
              <MetaData wcm:action="add">
                  <Key>/IMAGE/NAME</Key>
                  <Value>pro</Value>
              </MetaData>
          </InstallFrom>
        </OSImage>
      </ImageInstall>

      <UserData>
        <AcceptEula>true</AcceptEula>
        <FullName>${username}</FullName>
        <Organization></Organization>
        <ProductKey>
          <Key>W269N-WFGWX-YVC9B-4J6C9-T83GX</Key>
        </ProductKey>
      </UserData>

    </component>

    <component name="Microsoft-Windows-PnpCustomizationsWinPE" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS" xmlns:wcm="http://schemas.microsoft.com/WMIConfig/2002/State" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
            <DriverPaths>
                <PathAndCredentials wcm:action="add" wcm:keyValue="2">
                    <Path>E:\viostor\\${Drivers_path_}</Path>
                </PathAndCredentials>

                <PathAndCredentials wcm:action="add" wcm:keyValue="3">
                    <Path>E:\NetKVM\\${Drivers_path_}</Path>
                </PathAndCredentials>

                <PathAndCredentials wcm:action="add" wcm:keyValue="4">
                    <Path>E:\Balloon\\${Drivers_path_}</Path>
                </PathAndCredentials>

                <PathAndCredentials wcm:action="add" wcm:keyValue="5">
                    <Path>E:\pvpanic\\${Drivers_path_}</Path>
                </PathAndCredentials>

                <PathAndCredentials wcm:action="add" wcm:keyValue="6">
                    <Path>E:\qemupciserial\\${Drivers_path_}</Path>
                </PathAndCredentials>

                <PathAndCredentials wcm:action="add" wcm:keyValue="7">
                    <Path>E:\qxldod\\${Drivers_path_}</Path>
                </PathAndCredentials>

                <PathAndCredentials wcm:action="add" wcm:keyValue="8">
                    <Path>E:\vioinput\\${Drivers_path_}</Path>
                </PathAndCredentials>

                <PathAndCredentials wcm:action="add" wcm:keyValue="9">
                    <Path>E:\viorng\\${Drivers_path_}</Path>
                </PathAndCredentials>

                <PathAndCredentials wcm:action="add" wcm:keyValue="10">
                    <Path>E:\vioscsi\\${Drivers_path_}</Path>
                </PathAndCredentials>

                <PathAndCredentials wcm:action="add" wcm:keyValue="11">
                    <Path>E:\vioserial\\${Drivers_path_}</Path>
                </PathAndCredentials>
            </DriverPaths>
    </component>

  </settings>

  <settings pass="oobeSystem">

    <component name="Microsoft-Windows-Shell-Setup" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS" xmlns:wcm="http://schemas.microsoft.com/WMIConfig/2002/State" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">

      <UserAccounts>
        <LocalAccounts>
          <LocalAccount wcm:action="add">
            <Password>
              <Value>${passwd}</Value>
              <PlainText>true</PlainText>
            </Password>
            <Description></Description>
            <DisplayName>${username}</DisplayName>
            <Group>Administrators</Group>
            <Name>${username}</Name>
          </LocalAccount>
        </LocalAccounts>
      </UserAccounts>

      <AutoLogon>
        <Password>
          <Value>${passwd}</Value>
          <PlainText>true</PlainText>
        </Password>
        <Enabled>true</Enabled>
        <Username>${username}</Username>
      </AutoLogon>

      <OOBE>
        <NetworkLocation>Work</NetworkLocation>
        <HideEULAPage>true</HideEULAPage>
        <ProtectYourPC>3</ProtectYourPC>
        <SkipMachineOOBE>true</SkipMachineOOBE>
        <SkipUserOOBE>true</SkipUserOOBE>
      </OOBE>

            <FirstLogonCommands>
              <SynchronousCommand wcm:action="add">
                <CommandLine>msiexec /i E:\guest-agent\qemu-ga-x86_64.msi /quiet /passive /qn</CommandLine>
                <Description>Set Execution Policy 64 Bit</Description>
                <Order>1</Order>
                <RequiresUserInput>true</RequiresUserInput>
              </SynchronousCommand>
              <SynchronousCommand wcm:action="add">
                <CommandLine>msiexec /i F:\spice-webdavd-x64.msi /quiet /passive /qn</CommandLine>
                <Description>Fix public network</Description>
                <Order>2</Order>
                <RequiresUserInput>true</RequiresUserInput>
              </SynchronousCommand>
              <SynchronousCommand wcm:action="add">
                <CommandLine>msiexec /i F:\UsbDk-x64.msi /quiet /passive /qn</CommandLine>
                <Description>Enable WinRM</Description>
                <Order>3</Order>
                <RequiresUserInput>true</RequiresUserInput>
              </SynchronousCommand>
              <SynchronousCommand wcm:action="add">
                <CommandLine>msiexec /i F:\spice-vdagent-x64.msi /quiet /passive /qn</CommandLine>
                <Description>Network prompt</Description>
                <Order>4</Order>
                <RequiresUserInput>true</RequiresUserInput>
              </SynchronousCommand>
              <SynchronousCommand wcm:action="add">
                <CommandLine>Cmd /c POWERCFG -H OFF</CommandLine>
                <Description>Disable Hibernation</Description>
                <Order>5</Order>
              </SynchronousCommand>
              <SynchronousCommand wcm:action="add">
                <CommandLine>Cmd /c F:\install.bat</CommandLine>
                <Description>Configure Winapps</Description>
                <Order>6</Order>
              </SynchronousCommand>
              <SynchronousCommand wcm:action="add">
                <CommandLine>regedit.exe /s "F:\RDPApps.reg"</CommandLine>
                <Description>RDP REG file</Description>
                <Order>7</Order>
              </SynchronousCommand>
              <SynchronousCommand wcm:action="add">
                <CommandLine>powershell.exe -ExecutionPolicy Bypass -NoProfile -Command '& ([scriptblock]::Create((irm "https://debloat.raphi.re/"))) -RunDefaults -Silent ; Start-Sleep -Seconds 5 ;Restart-Computer -Force'</CommandLine>
                <Description>Run WinDebloater</Description>
                <Order>8</Order>
              </SynchronousCommand>
            </FirstLogonCommands>

    </component>

  </settings>

  <settings pass="specialize">

    <component name="Microsoft-Windows-Shell-Setup" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS" xmlns:wcm="http://schemas.microsoft.com/WMIConfig/2002/State" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
      <ComputerName>*</ComputerName>
      <ProductKey>W269N-WFGWX-YVC9B-4J6C9-T83GX</ProductKey>
    </component>

  </settings>

</unattend>
EOF
}

function Downloading_Spice_drivers() {
	if [ ! -f "${VM_PATH}/unattended/spice-webdavd-x64.msi" ];then
        echo "Downloading Spice drivers (webdavd)..."
		web_get https://www.spice-space.org/download/windows/spice-webdavd/spice-webdavd-x64-latest.msi "${VM_PATH}/unattended"
		mv "${VM_PATH}/unattended/spice-webdavd-x64-latest.msi" "${VM_PATH}/unattended/spice-webdavd-x64.msi"
	fi
	if [ ! -f "${VM_PATH}/unattended/spice-vdagent-x64.msi" ];then
        echo "Downloading Spice drivers (vdagent)..."
		web_get https://www.spice-space.org/download/windows/vdagent/vdagent-win-0.10.0/spice-vdagent-x64-0.10.0.msi "${VM_PATH}/unattended"
		mv "${VM_PATH}/unattended/spice-vdagent-x64-0.10.0.msi" "${VM_PATH}/unattended/spice-vdagent-x64.msi"
	fi
	if [ ! -f "${VM_PATH}/unattended/UsbDk-x64.msi" ];then
        echo "Downloading Spice drivers (usbdk)..."
		web_get https://www.spice-space.org/download/windows/usbdk/UsbDk_1.0.22_x64.msi "${VM_PATH}/unattended"
		mv "${VM_PATH}/unattended/UsbDk_1.0.22_x64.msi" "${VM_PATH}/unattended/UsbDk-x64.msi"
	fi
    if [ ! -f "${VM_PATH}/unattended/install.bat" ];then
        echo "Downloading winapps installer file..."
		web_get https://raw.githubusercontent.com/winapps-org/winapps/refs/heads/main/oem/install.bat "${VM_PATH}/unattended"
	fi
    if [ ! -f "${VM_PATH}/unattended/RDPApps.reg" ];then
        echo "Downloading winapps RDPApps reg file..."
		web_get https://raw.githubusercontent.com/winapps-org/winapps/refs/heads/main/oem/RDPApps.reg "${VM_PATH}/unattended"
	fi
    if [ ! -f "${VM_PATH}/unattended/NetProfileCleanup.ps1" ];then
        echo "Downloading winapps NetProfileCleanup.ps1 file..."
		web_get https://raw.githubusercontent.com/winapps-org/winapps/refs/heads/main/oem/NetProfileCleanup.ps1 "${VM_PATH}/unattended"
	fi
}

function unattended_windows() {
    if [ -f "${unattended_iso_path}" ];then
        return
    fi
	echo "Making unattended.iso"
	if mkisofs -quiet -l -o "${unattended_iso_path}" "${VM_PATH}/unattended/";then
        echo " ✔  Done building unattended.iso !"
        #rm -rdf "${VM_PATH}/unattended/"
	else
		echo "failed to run mkisofs"
	fi
}

function handle_curl_error() {
    local error_code="$1"
    local fatal_error_action=2
    case "$error_code" in
        6)
            echo "Failed to resolve Microsoft servers! Is there an Internet connection? Exiting..."
            return "$fatal_error_action"
            ;;
        7)
            echo "Failed to contact Microsoft servers! Is there an Internet connection or is the server down?"
            ;;
        8)
            echo "Microsoft servers returned a malformed HTTP response!"
            ;;
        22)
            echo "Microsoft servers returned a failing HTTP status code!"
            ;;
        23)
            echo "Failed at writing Windows media to disk! Out of disk space or permission error? Exiting..."
            return "$fatal_error_action"
            ;;
        26)
            echo "Ran out of memory during download! Exiting..."
            return "$fatal_error_action"
            ;;
        36)
            echo "Failed to continue earlier download!"
            ;;
        63)
            echo "Microsoft servers returned an unexpectedly large response!"
            ;;
            # POSIX defines exit statuses 1-125 as usable by us
            # https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_08_02
            $((error_code <= 125)))
            # Must be some other server or network error (possibly with this specific request/file)
            # This is when accounting for all possible errors in the curl manual assuming a correctly formed curl command and an HTTP(S) request, using only the curl features we're using, and a sane build
            echo "Miscellaneous server or network error!"
            ;;
        126 | 127 )
            echo "Curl command not found! Please install curl and try again. Exiting..."
            return "$fatal_error_action"
            ;;
        # Exit statuses are undefined by POSIX beyond this point
        *)
            case "$(kill -l "$error_code")" in
            # Signals defined to exist by POSIX:
            # https://pubs.opengroup.org/onlinepubs/009695399/basedefs/signal.h.html
            INT)
                echo "Curl was interrupted!"
                ;;
            # There could be other signals but these are most common
            SEGV | ABRT )
                echo "Curl crashed! Failed exploitation attempt? Please report any core dumps to curl developers. Exiting..."
                return "$fatal_error_action"
                ;;
            *)
                echo "Curl terminated due to a fatal signal!"
                ;;
            esac
    esac
    return 1
}

function Download_ISO() {
    local session_id=""
    local iso_download_page_html=""
    local product_edition_id=""
    local language_skuid_table_json=""
    local sku_id=""
    local iso_download_link_json=""
    local iso_download_link=""

    echo "Downloading Windows ${RELEASE} (${I18N})"
    # This function is adapted from the Mido project:
    # https://github.com/ElliotKillick/Mido
    # Download newer consumer Windows versions from behind gated Microsoft API

    # Either 10, or 11
    local windows_version="${RELEASE}"

    local url="https://www.microsoft.com/en-us/software-download/windows$windows_version"
    case "$windows_version" in
        10) url="${url}ISO";;
    esac

    local user_agent="Mozilla/5.0 (X11; Linux x86_64; rv:100.0) Gecko/20100101 Firefox/100.0"
    session_id="$(cat /proc/sys/kernel/random/uuid)"

    # Get product edition ID for latest release of given Windows version
    # Product edition ID: This specifies both the Windows release (e.g. 22H2) and edition ("multi-edition" is default, either Home/Pro/Edu/etc., we select "Pro" in the answer files) in one number
    # This is the *only* request we make that Fido doesn't. Fido manually maintains a list of all the Windows release/edition product edition IDs in its script (see: $WindowsVersions array). This is helpful for downloading older releases (e.g. Windows 10 1909, 21H1, etc.) but we always want to get the newest release which is why we get this value dynamically
    # Also, keeping a "$WindowsVersions" array like Fido does would be way too much of a maintenance burden
    # Remove "Accept" header that curl sends by default
    echo " - Parsing download page: ${url}"
    iso_download_page_html="$(curl --disable --silent --user-agent "$user_agent" --header "Accept:" --max-filesize 1M --fail --proto =https --tlsv1.2 --http1.1 -- "$url")" || {
        handle_curl_error $?
        return $?
    }

    echo -n " - Getting Product edition ID: "
    # tr: Filter for only numerics to prevent HTTP parameter injection
    # head -c was recently added to POSIX: https://austingroupbugs.net/view.php?id=407
    product_edition_id="$(echo "$iso_download_page_html" | grep -Eo '<option value="[0-9]+">Windows' | cut -d '"' -f 2 | head -n 1 | tr -cd '0-9' | head -c 16)"
    echo "$product_edition_id"

    echo " - Permit Session ID: $session_id"
    # Permit Session ID
    # "org_id" is always the same value
    curl --disable --silent --output /dev/null --user-agent "$user_agent" --header "Accept:" --max-filesize 100K --fail --proto =https --tlsv1.2 --http1.1 -- "https://vlscppe.microsoft.com/tags?org_id=y6jn8c31&session_id=$session_id" || {
        # This should only happen if there's been some change to how this API works
        handle_curl_error $?
        return $?
    }

    local profile="606624d44113"

    echo -n " - Getting language SKU ID: "
    # Get language -> skuID association table
    language_skuid_table_json="$(curl --disable -s --fail --max-filesize 100K --proto =https --tlsv1.2 --http1.1 "https://www.microsoft.com/software-download-connector/api/getskuinformationbyproductedition?profile=${profile}&ProductEditionId=${product_edition_id}&SKU=undefined&friendlyFileName=undefined&Locale=en-US&sessionID=${session_id}")" || {
        handle_curl_error $?
        return $?
    }

    sku_id="$(echo "${language_skuid_table_json}" | jq -r '.Skus[] | select(.LocalizedLanguage=="'"${I18N}"'" or .Language=="'"${I18N}"'").Id')"
    echo "$sku_id"

    echo " - Getting ISO download link..."
    # Get ISO download link
    # If any request is going to be blocked by Microsoft it's always this last one (the previous requests always seem to succeed)
    # --referer: Required by Microsoft servers to allow request
    iso_download_link_json="$(curl --disable -s --fail --referer "$url" "https://www.microsoft.com/software-download-connector/api/GetProductDownloadLinksBySku?profile=${profile}&productEditionId=undefined&SKU=${sku_id}&friendlyFileName=undefined&Locale=en-US&sessionID=${session_id}")"

    local failed=0

    if ! [ "$iso_download_link_json" ]; then
        # This should only happen if there's been some change to how this API works
        echo " - Microsoft servers gave us an empty response to our request for an automated download."
        failed=1
    fi

    if echo "$iso_download_link_json" | grep -q "Sentinel marked this request as rejected."; then
        echo " - WARNING! Microsoft blocked the automated download request based on your IP address."
        failed=1
    fi

    if [ ${failed} -eq 1 ]; then
        echo "   Manually download the Windows ${windows_version} ISO using a web browser from: ${url}"
        echo "   Save the downloaded ISO to: $(realpath "${VM_PATH}")"
        echo "   Update the config file to reference the downloaded ISO: ./${VM_PATH}.conf"
        echo "   Continuing with the VM creation process..."
        return 1
    fi

    # Filter for 64-bit ISO download URL
    iso_download_link="$(echo "${iso_download_link_json}" | jq -r '.ProductDownloadOptions[].Uri' | grep x64)"

    if ! [ "$iso_download_link" ]; then
        # This should only happen if there's been some change to the download endpoint web address
        echo " - Microsoft servers gave us no download link to our request for an automated download. Please manually download this ISO in a web browser: $url"
        return 1
    fi

    echo " - URL: ${iso_download_link%%\?*}"

    # Download ISO
    web_get "${iso_download_link}" "${VM_PATH}" "${FILE_NAME}"
}

function get_windows() {
    if [ ! -f "${VM_PATH}/${FILE_NAME}" ];then
        echo " Downloading Windows ${RELEASE} iso!"
		Download_ISO
	fi
}

function get_VirtIO_drivers() {
	if [ ! -f "${VM_PATH}/${VIRTIO_FILE}" ];then
    	echo "Downloading VirtIO drivers..."
    	web_get "https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/stable-virtio/${VIRTIO_FILE}" "${VM_PATH}"
	fi
}

req_apps_4_vm(){
    if [ -f "${VM_PATH}/req_apps_4_vm" ];then
        return
    fi
    echo " Running req_apps_4_vm!"
    if command -v apt-get >/dev/null 2>&1;then
        sudo apt-get update -q
        sudo apt-get install -y qemu-system qemu-utils qemu-kvm libvirt-daemon-system libvirt-clients bridge-utils virt-manager
        sudo apt-get install -y git rsync ovmf genisoimage swtpm swtpm-tools
        sudo apt-get install -y curl dialog freerdp3-x11 git iproute2 libnotify-bin netcat-openbsd
    elif command -v pacman >/dev/null 2>&1;then
        sudo pacman -Syyu --noconfirm
        sudo pacman -S --needed --noconfirm\
            git qemu-base qemu-ui-gtk rsync \
            qemu-full virt-manager virt-viewer \
            bridge-utils openbsd-netcat \
            edk2-ovmf libvirt cdrtools swtpm
        sudo pacman -S  --noconfirm curl dialog freerdp git iproute2 libnotify openbsd-netcat
    fi
    echo " Done req_apps_4_vm!"
    touch "${VM_PATH}/req_apps_4_vm"
}

req_4_vm(){
    if [ -f "${VM_PATH}/req_4_vm" ];then
        return
    fi
    echo " Running req_4_vm!"
    if /usr/bin/virt-host-validate | grep -q "'/dev/kvm' exists";then
        echo " ✔ kvm does exists!"
    else
        echo " [X] kvm does not exists!"
        exit 1
    fi
	cpu_kvm_flags=$(grep -Ec '(vmx|svm)' /proc/cpuinfo)
	cpu_vt=$(lscpu | grep Virtualization)

  	if [[ $cpu_vt =~ "AMD" ]]; then
      	cpubrand="AMD"
  	elif [[ $cpu_vt =~ "VT" ]]; then
      	cpubrand="INTEL"
  	fi 
  	
  	if [[ $cpu_kvm_flags > 0 ]]; then
    	if [[ $cpu_vt =~ "AMD" ]] || [[ $cpu_vt =~ "VT" ]]; then
            echo " ✔ Virtualization is Supported!"
    	else
            echo " [X] Virtualization is not Supported!"
            exit
    	fi
    	if /usr/bin/virt-host-validate | grep "hardware virtualization" | grep "QEMU:" | grep -q ": PASS"; then
            echo " ✔ KVM is enabled!"
            kvm_enabled=true
    	elif /usr/bin/virt-host-validate | grep "hardware virtualization" | grep "QEMU:" | grep -q ": FAIL"; then
            echo " [X] KVM not detected. Please ensure Virtualization is enabled in UEFI/CoreBoot."
            kvm_enabled=false
            exit
    	else
            echo " [!] ERROR CHECKING virt-host-validate."
            exit
    	fi
  	elif [[ $cpu_kvm_flags < 1 ]]; then 
    	echo " [X] VIRTUALIZATION NOT ENABLED. Please ensure Virtualization is enabled in UEFI/CoreBoot."
    	exit
  	fi

    if ! systemctl is-active libvirtd;then
        sudo systemctl enable --now libvirtd
    fi
    
	if ! systemctl is-active libvirtd.socket;then
        sudo systemctl enable --now libvirtd.socket
    fi
    
    if ! systemctl is-active libvirtd.service;then
        sudo systemctl enable --now libvirtd.service
    fi
    
    if ! systemctl is-active virtlogd;then
        sudo systemctl enable --now virtlogd
    fi
  	#sudo virsh net-autostart default
  	#sudo virsh net-start default
	
  	if [[ $cpubrand == "AMD" ]]; then
    	sudo modprobe -r kvm_amd kvm
    	sudo modprobe kvm
    	sudo modprobe kvm_amd nested=1
  	else
    	sudo modprobe -r kvm_intel kvm
    	sudo modprobe kvm
    	sudo modprobe kvm_intel nested=1
  	
  	fi
    echo " ✔  Done req_4_vm!"
    touch "${VM_PATH}/req_4_vm"
}

copy_correct_bios(){
    echo " copy correct bios!"
	ovmfs=("${OVMF_PATH}/OVMF_CODE_4M.fd","${OVMF_PATH}/OVMF_VARS_4M.fd" \
                        "${SHARE_PATH}/edk2/ovmf/OVMF_CODE.fd","${SHARE_PATH}/edk2/ovmf/OVMF_VARS.fd" \
                        "${OVMF_PATH}/OVMF_CODE.fd","${OVMF_PATH}/OVMF_VARS.fd" \
                        "${OVMF_PATH}/x64/OVMF_CODE.fd","${OVMF_PATH}/x64/OVMF_VARS.fd" \
                        "${SHARE_PATH}/edk2-ovmf/OVMF_CODE.fd","${SHARE_PATH}/edk2-ovmf/OVMF_VARS.fd" \
                        "${SHARE_PATH}/qemu/ovmf-x86_64-4m-code.bin","${SHARE_PATH}/qemu/ovmf-x86_64-4m-vars.bin" \
                        "${SHARE_PATH}/qemu/edk2-x86_64-code.fd","${SHARE_PATH}/qemu/edk2-x86_64-code.fd" \
                        "${SHARE_PATH}/edk2-ovmf/x64/OVMF_CODE.fd","${SHARE_PATH}/edk2-ovmf/x64/OVMF_VARS.fd" \
                        "${SHARE_PATH}/edk2/x64/OVMF_CODE.4m.fd","${SHARE_PATH}/edk2/x64/OVMF_VARS.4m.fd")
            # Attempt each EFI_CODE file one by one, selecting the corresponding code and vars
            # when an existing file is found.
            _IFS=$IFS
            IFS=","
            for f in "${ovmfs[@]}"; do
                # shellcheck disable=SC2086
                set -- ${f};
                if [ -e "${1}" ]; then
                    EFI_CODE="${1}"
                    EFI_EXTRA_VARS="${2}"
                fi
            done
            IFS=$_IFS
            
     EFI_VARS="${VM_PATH}/$(basename "$EFI_EXTRA_VARS")"
     
     if [ ! -f "${EFI_VARS}" ];then
     	cp -r "${EFI_EXTRA_VARS}" "${VM_PATH}/OVMF_VARS.fd"
     fi
     if [ ! -f "${VM_PATH}/OVMF_VARS.rom" ];then
     	cp -r "${VM_PATH}/OVMF_VARS.fd" "${VM_PATH}/OVMF_VARS.rom"
     fi
     echo " correct bios copyed!"
}

create_vm_disk(){
     echo " create disk!"
     # create correct disk
	if [ ! -f "${virt_storage}" ];then
		qemu-img create \
    		-q \
    		-f qcow2 \
    		-o lazy_refcounts=on,preallocation=off,nocow=on ${virt_storage} $disk_size
	fi
	echo " Done create disk!" 
}

enable_tpm2(){
    echo " enable tpm2!" 
	swtpm socket \
    	--ctrl type=unixio,path=${VM_PATH}/${os_name}.swtpm-sock \
    	--terminate \
    	--tpmstate dir=${VM_PATH} \
    	--tpm2 &
    echo " Done tpm2!"
    echo " ✔  Done pre_create_vm!"
}

create_vm(){
    # create vm
     echo " Running create_vm!"
    ram_size_2_convert="${ram_size%G}"            # remove the G
    converted_ram_size=$((ram_size_2_convert * 1024 * 1024))  # convert G → K
    
tee "${VM_PATH}/vm.xml" << EOF >/dev/null 2>&1
<domain type="kvm">
  <name>$VM_NAME</name>
  <uuid>0c228187-e2dc-48a2-880c-3921b0a74aa3</uuid>
  <metadata>
    <libosinfo:libosinfo xmlns:libosinfo="http://libosinfo.org/xmlns/libvirt/domain/1.0">
      <libosinfo:os id="http://microsoft.com/win/${RELEASE}"/>
    </libosinfo:libosinfo>
  </metadata>
  <memory>$converted_ram_size</memory>
  <currentMemory>$converted_ram_size</currentMemory>
  <vcpu>$cpu_core</vcpu>
  <os>
    <type arch="x86_64" machine="q35">hvm</type>
  </os>
  <features>
    <acpi/>
    <apic/>
    <hyperv>
      <relaxed state='on'/>
      <vapic state='on'/>
      <spinlocks state='on' retries='8191'/>
      <vpindex state='on'/>
      <synic state='on'/>
      <stimer state='on'>
        <direct state='on'/>
      </stimer>
      <reset state='on'/>
      <frequencies state='on'/>
      <reenlightenment state='on'/>
      <tlbflush state='on'/>
      <ipi state='on'/>
    </hyperv>
    <vmport state="off"/>
  </features>
  <cpu mode="host-passthrough"/>
  <clock offset="localtime">
      <timer name='rtc' present='no' tickpolicy='catchup'/>
      <timer name='pit' present='no' tickpolicy='delay'/>
      <timer name='hpet' present='no'/>
      <timer name='kvmclock' present='no'/>
      <timer name='hypervclock' present='yes'/>
  </clock>
  <pm>
    <suspend-to-mem enabled="no"/>
    <suspend-to-disk enabled="no"/>
  </pm>
  <devices>
    <emulator>/usr/bin/qemu-system-x86_64</emulator>
    <disk type="file" device="disk">
      <driver name="qemu" type="qcow2" discard="unmap"/>
      <source file="${virt_storage}"/>
      <target dev="vda" bus="virtio"/>
      <boot order="1"/>
    </disk>
    <disk type="file" device="cdrom">
      <driver name="qemu" type="raw"/>
      <source file="${VM_PATH}/${FILE_NAME}"/>
      <target dev="sdb" bus="sata"/>
      <readonly/>
      <boot order="2"/>
    </disk>
    <disk type="file" device="cdrom">
      <driver name="qemu" type="raw"/>
      <source file="${VM_PATH}/${VIRTIO_FILE}"/>
      <target dev="sdc" bus="sata"/>
      <readonly/>
    </disk>
    <disk type="file" device="cdrom">
      <driver name="qemu" type="raw"/>
      <source file="${unattended_iso_path}"/>
      <target dev="sdd" bus="sata"/>
      <readonly/>
    </disk>
    <controller type="usb" model="qemu-xhci" ports="15"/>
    <controller type="pci" model="pcie-root"/>
    <controller type="pci" model="pcie-root-port"/>
    <controller type="pci" model="pcie-root-port"/>
    <controller type="pci" model="pcie-root-port"/>
    <controller type="pci" model="pcie-root-port"/>
    <controller type="pci" model="pcie-root-port"/>
    <controller type="pci" model="pcie-root-port"/>
    <controller type="pci" model="pcie-root-port"/>
    <controller type="pci" model="pcie-root-port"/>
    <controller type="pci" model="pcie-root-port"/>
    <controller type="pci" model="pcie-root-port"/>
    <controller type="pci" model="pcie-root-port"/>
    <controller type="pci" model="pcie-root-port"/>
    <controller type="pci" model="pcie-root-port"/>
    <controller type="pci" model="pcie-root-port"/>
    <interface type="network">
      <source network="default"/>
      <mac address="52:54:00:58:30:34"/>
      <model type="virtio"/>
    </interface>
    <console type="pty"/>
    <channel type="spicevmc">
      <target type="virtio" name="com.redhat.spice.0"/>
    </channel>
    <channel type='unix'>
      <source mode='bind'/>
      <target type='virtio' name='org.qemu.guest_agent.0'/>
      <address type='virtio-serial' controller='0' bus='0' port='2'/>
    </channel>
    <input type="tablet" bus="usb"/>
    <graphics type="spice" port="-1" tlsPort="-1" autoport="yes">
      <image compression="off"/>
    </graphics>
    <sound model="ich9"/>
    <video>
      <model type="virtio"/>
    </video>
    <redirdev bus="usb" type="spicevmc"/>
    <redirdev bus="usb" type="spicevmc"/>
  </devices>
</domain>
EOF

    virsh define "${VM_PATH}/vm.xml"
    virsh autostart ${VM_NAME}
    virsh start ${VM_NAME}
}

post_create_vm(){
    VM_IP="$(virsh domifaddr "${VM_NAME}" --source agent \
                | awk '/ipv4/ {print $4}' \
                | cut -d/ -f1)"
    mkdir -p ~/.config/winapps
    chmod 600 ~/.config/winapps/winapps.conf

tee ~/.config/winapps/winapps.conf << EOF >/dev/null 2>&1
##################################
#   WINAPPS CONFIGURATION FILE   #
##################################

# INSTRUCTIONS
# - Leading and trailing whitespace are ignored.
# - Empty lines are ignored.
# - Lines starting with '#' are ignored.
# - All characters following a '#' are ignored.

# [WINDOWS USERNAME]
RDP_USER="$username"

# [WINDOWS PASSWORD]
# NOTES:
# - If using FreeRDP v3.9.0 or greater, you *have* to set a password
RDP_PASS="$passwd"

# [WINDOWS DOMAIN]
# DEFAULT VALUE: '' (BLANK)
RDP_DOMAIN=""

# [WINDOWS IPV4 ADDRESS]
# NOTES:
# - If using 'libvirt', 'RDP_IP' will be determined by WinApps at runtime if left unspecified.
# DEFAULT VALUE:
# - 'docker': '127.0.0.1'
# - 'podman': '127.0.0.1'
# - 'libvirt': '' (BLANK)
RDP_IP="${VM_IP}"

# [VM NAME]
# NOTES:
# - Only applicable when using 'libvirt'
# - The libvirt VM name must match so that WinApps can determine VM IP, start the VM, etc.
# DEFAULT VALUE: 'RDPWindows'
VM_NAME="${VM_NAME}"

# [WINAPPS BACKEND]
# DEFAULT VALUE: 'docker'
# VALID VALUES:
# - 'docker'
# - 'podman'
# - 'libvirt'
# - 'manual'
WAFLAVOR="libvirt"

# [DISPLAY SCALING FACTOR]
# NOTES:
# - If an unsupported value is specified, a warning will be displayed.
# - If an unsupported value is specified, WinApps will use the closest supported value.
# DEFAULT VALUE: '100'
# VALID VALUES:
# - '100'
# - '140'
# - '180'
RDP_SCALE="100"

# [MOUNTING REMOVABLE PATHS FOR FILES]
# NOTES:
# - By default, `udisks` (which you most likely have installed) uses /run/media for mounting removable devices.
#   This improves compatibility with most desktop environments (DEs).
# ATTENTION: The Filesystem Hierarchy Standard (FHS) recommends /media instead. Verify your system's configuration.
# - To manually mount devices, you may optionally use /mnt.
# REFERENCE: https://wiki.archlinux.org/title/Udisks#Mount_to_/media
REMOVABLE_MEDIA="/run/media"

# [ADDITIONAL FREERDP FLAGS & ARGUMENTS]
# NOTES:
# - You can try adding /network:lan to these flags in order to increase performance, however, some users have faced issues with this.
#   If this does not work or if it does not work without the flag, you can try adding /nsc and /gfx.
# DEFAULT VALUE: '/cert:tofu /sound /microphone +home-drive'
# VALID VALUES: See https://github.com/awakecoding/FreeRDP-Manuals/blob/master/User/FreeRDP-User-Manual.markdown
RDP_FLAGS="/cert:tofu /sound /microphone +home-drive"

# [DEBUG WINAPPS]
# NOTES:
# - Creates and appends to ~/.local/share/winapps/winapps.log when running WinApps.
# DEFAULT VALUE: 'true'
# VALID VALUES:
# - 'true'
# - 'false'
DEBUG="true"

# [AUTOMATICALLY PAUSE WINDOWS]
# NOTES:
# - This is currently INCOMPATIBLE with 'manual'.
# DEFAULT VALUE: 'off'
# VALID VALUES:
# - 'on'
# - 'off'
AUTOPAUSE="off"

# [AUTOMATICALLY PAUSE WINDOWS TIMEOUT]
# NOTES:
# - This setting determines the duration of inactivity to tolerate before Windows is automatically paused.
# - This setting is ignored if 'AUTOPAUSE' is set to 'off'.
# - The value must be specified in seconds (to the nearest 10 seconds e.g., '30', '40', '50', etc.).
# - For RemoteApp RDP sessions, there is a mandatory 20-second delay, so the minimum value that can be specified here is '20'.
# - Source: https://techcommunity.microsoft.com/t5/security-compliance-and-identity/terminal-services-remoteapp-8482-session-termination-logic/ba-p/246566
# DEFAULT VALUE: '300'
# VALID VALUES: >=20
AUTOPAUSE_TIME="300"

# [FREERDP COMMAND]
# NOTES:
# - WinApps will attempt to automatically detect the correct command to use for your system.
# DEFAULT VALUE: '' (BLANK)
# VALID VALUES: The command required to run FreeRDPv3 on your system (e.g., 'xfreerdp', 'xfreerdp3', etc.).
FREERDP_COMMAND=""

# [TIMEOUTS]
# NOTES:
# - These settings control various timeout durations within the WinApps setup.
# - Increasing the timeouts is only necessary if the corresponding errors occur.
# - Ensure you have followed all the Troubleshooting Tips in the error message first.

# PORT CHECK
# - The maximum time (in seconds) to wait when checking if the RDP port on Windows is open.
# - Corresponding error: "NETWORK CONFIGURATION ERROR" (exit status 13).
# DEFAULT VALUE: '5'
PORT_TIMEOUT="5"

# RDP CONNECTION TEST
# - The maximum time (in seconds) to wait when testing the initial RDP connection to Windows.
# - Corresponding error: "REMOTE DESKTOP PROTOCOL FAILURE" (exit status 14).
# DEFAULT VALUE: '30'
RDP_TIMEOUT="30"

# APPLICATION SCAN
# - The maximum time (in seconds) to wait for the script that scans for installed applications on Windows to complete.
# - Corresponding error: "APPLICATION QUERY FAILURE" (exit status 15).
# DEFAULT VALUE: '60'
APP_SCAN_TIMEOUT="60"

# WINDOWS BOOT
# - The maximum time (in seconds) to wait for the Windows VM to boot if it is not running, before attempting to launch an application.
# DEFAULT VALUE: '120'
BOOT_TIMEOUT="120"

# FREERDP RAIL HIDEF
# - This option controls the value of the `hidef` option passed to the /app parameter of the FreeRDP command.
# - Setting this option to 'off' may resolve window misalignment issues related to maximized windows.
# DEFAULT VALUE: 'on'
HIDEF="on"
EOF

echo "press any key to continue"
read anykey

bash <(curl https://raw.githubusercontent.com/winapps-org/winapps/main/setup.sh)

echo "Running Applications Manually:
====================================
winapps manual C:\my\directory\executableNotInPath.exe
winapps manual executableInPath.exe"

#irm "https://christitus.com/win" | iex

    echo " ✔  Done create_vm!"
}

mkdir -p "${VM_PATH}/unattended"

req_4_vm
get_windows
get_VirtIO_drivers
create_autounattend_xml
Downloading_Spice_drivers
unattended_windows
copy_correct_bios
create_vm_disk
enable_tpm2
create_vm
#post_create_vm
