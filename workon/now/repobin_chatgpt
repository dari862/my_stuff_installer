#!/bin/bash
set -e

### ─── Globals ──────────────────────────────────────────────

sudo_cmd="sudo"

# Paths
#. "/usr/share/my_stuff/lib/common/Distro_path"
__distro_path_root="/usr/share/my_stuff"
__distro_path_bin="$__distro_path_root/system_files/bin"
__distro_path_downloaded="$__distro_path_root/external/downloaded"
__distro_path_neverremove="$__distro_path_root/never_remove"

ROOT_CONFIG_FILE="$__distro_path_neverremove/installs.json"
USER_BIN_DIR="$HOME/.local/bin"
USER_CONFIG_DIR="$HOME/.config/my_stuff"
USER_CONFIG_FILE="$USER_CONFIG_DIR/installs.json"

# Defaults
USE_SUDO=false
MODE="bin"
EXT=""
TARGET_BINARY=""

# State
install_appimage=false
run_reinstall=false
if [[ "$(id -u)" -eq 0 ]];then
	config_file="$ROOT_CONFIG_FILE"
	bin_dir="$__distro_path_bin"
	sudo_cmd=""
else
	config_file="$USER_CONFIG_FILE"
	bin_dir="$USER_BIN_DIR"
fi
### ─── Utilities ────────────────────────────────────────────
log()  { printf "\033[1;34m[INFO]\033[0m %s\n" "$*"; }
warn() { printf "\033[1;33m[WARN]\033[0m %s\n" "$*" >&2; }
err()  { printf "\033[1;31m[ERROR]\033[0m %s\n" "$*" >&2; }

cleanup() { [[ -n "${tmp_file:-}" && -f "$tmp_file" ]] && rm -f "$tmp_file"; }
trap cleanup EXIT

safe_mv() {
    local suffix=""
    [[ -n "$EXT" ]] && suffix=".$EXT"
    $sudo_cmd mv "$tmp_file" "$bin_dir/${bin_name}${suffix}"
    $sudo_cmd chmod +x "$bin_dir/${bin_name}${suffix}"
}

### ─── Config ───────────────────────────────────────────────

declare -A config

load_config() {
    local file="$1"
    [[ -f "$file" ]] || return 0
    while IFS="=" read -r repo ver; do
        config["$repo"]="$ver"
    done < <(jq -r 'to_entries|map("\(.key)=\(.value)")|.[]' "$file")
}

save_config() {
    local json="{"
    for repo in "${!config[@]}"; do
        json+="\"$repo\":\"${config[$repo]}\"," 
    done
    json="${json%,}}"
    echo "$json" | jq . | $sudo_cmd tee "$config_file" >/dev/null
    log "Config saved to $config_file"
}

### ─── Installer Functions ──────────────────────────────────

verify_checksum() {
    local bin="$1" url="$2"
    local tmp_sum
    tmp_sum=$(mktemp)
    curl -sL "$url" -o "$tmp_sum"
    local expected actual
    expected=$(grep "$(basename "$bin")" "$tmp_sum" | awk '{print $1}')
    actual=$(sha256sum "$bin" | awk '{print $1}')
    if [[ "$expected" != "$actual" ]]; then
        err "Checksum mismatch for $(basename "$bin")"
        exit 1
    fi
    log "Checksum verified"
    rm -f "$tmp_sum"
}

extract_and_install() {
    local archive="$1"
    local dir
    dir=$(mktemp -d)
    case "$archive" in
        *.zip) unzip -q "$archive" -d "$dir" ;;
        *.tar.gz|*.tgz) tar -xf "$archive" -C "$dir" ;;
        *) err "Unsupported archive: $archive"; exit 1 ;;
    esac
    local found
    if [[ -n "$TARGET_BINARY" ]]; then
        found=$(find "$dir" -type f -name "$TARGET_BINARY" -perm -111 | head -n1)
    else
        found=$(find "$dir" -type f -perm -111 ! -name "*.so" ! -name "*.dll" ! -name "*.dylib" | head -n1)
    fi
    [[ -n "$found" ]] || { err "No executable found in archive"; exit 1; }
    tmp_file="$found"
    safe_mv
    rm -rf "$dir"
}

install_repo() {
    repo="$1"; version="${2:-}"
    bin_name="${repo##*/}"

    # Fetch release JSON
    local release_json
    if [[ -z "$version" ]]; then
        release_json=$(curl -sfL "https://api.github.com/repos/$repo/releases/latest")
        version=$(jq -r '.tag_name' <<<"$release_json")
    else
        release_json=$(curl -sfL "https://api.github.com/repos/$repo/releases/tags/$version")
    fi

    # Skip drafts/prereleases
    if [[ $(jq -r '.draft or .prerelease' <<<"$release_json") == "true" ]]; then
        warn "$repo release is draft/prerelease, skipping"
        return 1
    fi

    # Pick asset URL
    mapfile -t assets < <(jq -r '.assets[].browser_download_url' <<<"$release_json")
    asset_url="$(printf '%s\n' "${assets[@]}" | grep -Ei "linux.*amd64|x86_64.*linux" | grep -Ev 'sha256|.zsync' | head -n1)"

    [[ -n "$asset_url" ]] || { err "No suitable asset for $repo"; exit 1; }

    tmp_file=$(mktemp)
    log "Downloading $asset_url"
    curl -fL "$asset_url" -o "$tmp_file"

    case "$asset_url" in
        *.deb) $sudo_cmd apt-get install -y -f "$tmp_file" ;;
        *.appimage|*.AppImage|*.Appimage) EXT="appimage"; safe_mv ;;
        *.zip|*.tar.gz|*.tgz) extract_and_install "$tmp_file" ;;
        *) safe_mv ;;
    esac

    config["$repo"]="$version|$EXT"
    log "Installed $bin_name@$version"
}

### ─── Commands ─────────────────────────────────────────────

cmd_install() {
    local repo="$1" version="${2:-}"
    [[ -n "${config[$repo]:-}" && $run_reinstall == false ]] && { err "$repo already installed"; exit 1; }
    install_repo "$repo" "$version"
    save_config
}

cmd_update() {
    for repo in "${!config[@]}"; do
        log "Checking $repo"
        local latest
        latest=$(curl -sfL "https://api.github.com/repos/$repo/releases/latest" | jq -r '.tag_name')
        local installed="${config[$repo]}"
        if [[ "$latest" != "${installed%%|*}" ]]; then
            log "Updating $repo: $installed -> $latest"
            run_reinstall=true
            install_repo "$repo" "$latest"
        else
            log "$repo is up-to-date"
        fi
    done
    save_config
}

cmd_list() {
    [[ ${#config[@]} -eq 0 ]] && { echo "No binaries installed."; return; }
    for repo in "${!config[@]}"; do
        printf "%-30s %s\n" "$repo" "${config[$repo]}"
    done
}

cmd_remove() {
    local repo="$1"
    local bin_name="${repo##*/}"
    $sudo_cmd rm -f "$bin_dir/$bin_name" || true
    unset config["$repo"]
    save_config
    log "Removed $repo"
}

cmd_info() {
    local repo="$1"
    echo "Repository: $repo"
    echo "Installed: ${config[$repo]:-not installed}"
    local latest
    latest=$(curl -sfL "https://api.github.com/repos/$repo/releases/latest" | jq -r '.tag_name')
    echo "Latest: $latest"
}

print_help() {
    cat <<EOF
Usage: $0 [OPTIONS] <COMMAND> [ARGS...]

Commands:
  install <user/repo> [version]   Install a GitHub release
  update                          Update all installed binaries
  list                            List installed binaries
  remove <user/repo>              Remove binary
  info <user/repo>                Show info
  help                            Show help
EOF
}

### ─── Main ─────────────────────────────────────────────────

# Load config
load_config "$config_file"

cmd="${1:-help}"; shift || true
case "$cmd" in
  install)   [[ $# -lt 1 ]] && err "Usage: $0 install <user/repo> [version]" && exit 1; cmd_install "$@" ;;
  update)    cmd_update ;;
  list)      cmd_list ;;
  remove)    [[ $# -lt 1 ]] && err "Usage: $0 remove <user/repo>" && exit 1; cmd_remove "$1" ;;
  info)      [[ $# -lt 1 ]] && err "Usage: $0 info <user/repo>" && exit 1; cmd_info "$1" ;;
  help|*)    print_help ;;
esac
